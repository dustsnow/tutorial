Compile Command
g++ -g rrt-2-link-artm.cpp -L/usr/lib/fcl -I/usr/include/fcl -lfcl -o rrt

Why dists is doubled?
It indeed doubles the distance

index(dataset,...)
dataset has to be initialized. Otherwise, the unintializd part will be zero. for example
Matrix<double> dataset(new double[2],1,2);
Index<L2<double> > index(dataset,...)
Now even though dataset doesn't initialize. It's default value will be (0,0). Put it another way, when you add points, your points will be added at index 1 instead of 0;

Now it only work given inital joint values and final joint values. 
It must be improved by given inital joint values and final end-effactor coordinations.
Leave this task until collision check has been done;


Why knnSearch doesn't return the nearest point when the pt_target are randomly picked?
gdb debug info. 
It shows when using index.addPoints(pt_new), it actually add a reference to the pt_new. So whenever pt_new changes, every value added changes.
Solution Trial 1: The solution is dynamicly allocate pt_new everytime. Move the definition of pt_new into while loop in main function
│(gdb) call pi(index,5)                                                                                    
│0       0                                                                                                 
│-0.640184       0.768221                                                                                  
│-0.640184       0.768221                                                                                  
│-0.640184       0.768221                                                                                  
│-0.640184       0.768221                                                                                  
│(gdb) n                                                                                                   
│0.768221                                                                                                  
│138                     calculateNewPoint(pt_nearest, pt_target, pt_new);                                 
│(gdb) call pi(index,5)                                                                                    
│0       0                                                                                                 
│-0.640184       0.768221                                                                                  
│-0.640184       0.768221                                                                                  
│-0.640184       0.768221                                                                                  
│-0.640184       0.768221                                                                                  
│(gdb) n                                                                                                   
│                                                                                                          
│Breakpoint 5, main (argc=1, argv=) at rrt-2-link-artm.cpp:142                                             
│142                     if(calculateDistance(pt_goal, pt_new) <= step_size) break;                        
│(gdb) call pi(index,5)                                                                                    
│0       0                                                                                                 
│-1.35167        1.47092                                                                                   
│-1.35167        1.47092                                                                                   
│-1.35167        1.47092                                                                                   
│-1.35167        1.47092                                                                                   
│(gdb) 

After the addPoints bug, the tree doesn't seems right. Only four major branches in the graph. I guess that happened to demonstrate the rightness of possibilities.
After investigation, it turns out that the problem is at the random point generation. My code just generate integer number which is not sufficient in this 
RRT senerio.
Trial Solution 1: generate random float number, both positive and negative.
Result: even with random float number genration, rrt only gets a little bit better.
Trial Solution 2: improved trial solution 1. in trial solution 1, the x and y generator has the same limit, in this trial, make them unequal. Set the limit according 
to their inital and final value
Result: So much better. Try to find the solution, it takes 20000+ points to find the solution


How to initialized a fcl::Matrix3f? row first or column first?
row first.


Collision test between two rectangulars
First it does't return right result because I use the wrong rotation matrix. 
I set the rotation matrix as following:
	cos(p) -sin(p) 0
	sin(p) cos(p)  0
	0		0      0
I set those things related to z to 0, which is incorrect.
When rotate a rectangular on xy plane, it amounts to rotate around z axis. The right rotation matrix about the z-axis is
	cos(p) -sin(p) 0
	sin(p) cos(p)  0
	0		0      1


Unclear, "rotation about z-axis" is rotating respected to the center point or original point?
Trial 1, assume box rotate respect to original point(aka z-axix). Create a test: rotate box1 and box2 45 degrees. It assumption is correct, they wouldn't touch unless the distance between there center point < 2;
Trial 1 failed.
Trial 2, assume box rotate respect to their own center point. Make two box, they are on the side of each other. both rotate 45 degrees. if assumption is correct, they wouldn't collide unless the distance between their center points are < 2*(length of diagonal)
Trial 2 successed.


Why the collisionCheck function cannot access the obstacle defined in main:


How to write define doable obstacle?
run the rrt without obstacles. Pick a point from the result. Place the obstacle at this point.


Now the collision check works, the rrt can avoid the obstacles. But we need a way to retrive the path from rrt
Done!


3 link arm cannot find collision correctly.
rewrite calculating the new point code. Using vector manipulation to find the new point
Trial Solution 1: link 3 is not proporly positioned
Trial 1 sucessed. The problem is at the function "calcCenterPoint". 
NEVER DIVIED BY 2, DEVIDE 2.0 INSTAED


cannod print rectangular arms in octave
fixed. Problems:
calculate center point: point1_x + (point2_x - point1_x)/2
joint angle for link2 is ang(link1)+ang(link2)
rotatation improved, it's able to rotate around center point. Before, it can only rotate around origin
